'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var t = _ref['types'];

  // Tracking variables build during the AST pass. We instantiate
  // these in the `Program` visitor in order to support running the
  // plugin in watch mode or on multiple files.
  var lodashFpIdentifier = undefined,
      lodashObjs = undefined,
      fpObjs = undefined,
      fpSpecified = undefined,
      specified = undefined,
      selectedMethods = undefined;

  var CHAIN_ERROR = 'lodash chaining syntax is not yet supported';

  // Import a lodash method and return the computed import identifier.
  function importMethod(methodName, file) {
    if (!selectedMethods[methodName]) {
      var path = (0, _lodashModules2.default)(methodName);
      selectedMethods[methodName] = file.addImport(path, 'default');
    }
    return selectedMethods[methodName];
  }

  return {
    'visitor': {

      // Instantiate all the necessary tracking variables for this AST.
      'Program': {
        enter: function enter() {
          // Track the variables used to import lodash.
          lodashObjs = Object.create(null);
          specified = Object.create(null);

          // Trackers for lodash-fp support.
          fpObjs = Object.create(null);
          fpSpecified = Object.create(null);

          // Track the methods that have already been used to prevent dupe imports.
          selectedMethods = Object.create(null);
          lodashFpIdentifier = null;
        },
        exit: function exit(_ref2) {
          var hub = _ref2.hub;
          var node = _ref2.node;

          if (lodashFpIdentifier) {
            // Setup the lodash-fp instance with the selected methods.
            var id = hub.file.addImport('lodash/fp/convert', 'default');
            var fpSetup = t.callExpression(id, [t.objectExpression(_lodash2.default.map(selectedMethods, function (identifier, name) {
              return t.objectProperty(t.identifier(name), identifier);
            }))]);
            // Inject the setup into the top of the program (after imports).
            node.body.unshift(t.variableDeclaration('var', [t.variableDeclarator(lodashFpIdentifier, fpSetup)]));
          }
        }
      },

      ImportDeclaration: function ImportDeclaration(path) {
        var node = path.node;
        var scope = path.scope;
        var value = node.source.value;

        var fp = value == 'lodash/fp';

        if (fp || value == 'lodash') {
          node.specifiers.forEach(function (spec) {
            if (t.isImportSpecifier(spec)) {
              (fp ? fpSpecified : specified)[spec.local.name] = spec.imported.name;
            } else {
              (fp ? fpObjs : lodashObjs)[spec.local.name] = true;
            }
          });
          // Remove the original import node, for replacement.
          path.remove();
        }
        if (fp && !lodashFpIdentifier) {
          lodashFpIdentifier = scope.generateUidIdentifier('lodashFp');
        }
      },
      CallExpression: function CallExpression(path) {
        var node = path.node;
        var name = node.callee.name;
        var file = path.hub.file;


        if (!t.isIdentifier(node.callee)) {
          return;
        }
        if (specified[name]) {
          node.callee = importMethod(specified[name], file);
        } else if (fpSpecified[name]) {
          // Transform map() to fp.map() in order to avoid destructuring fp.
          importMethod(fpSpecified[name], file);
          node.callee = t.memberExpression(lodashFpIdentifier, t.identifier(fpSpecified[name]));
        }
        // Detect chaining via _(value).
        else if (lodashObjs[name]) {
            throw new Error(CHAIN_ERROR);
          }
        if (node.arguments) {
          node.arguments = node.arguments.map(function (arg) {
            var name = arg.name;

            return specified[name] ? importMethod(specified[name], file) : arg;
          });
        }
      },
      MemberExpression: function MemberExpression(path) {
        var node = path.node;
        var file = path.hub.file;


        if (lodashObjs[node.object.name] && node.property.name == 'chain') {
          // Detect chaining via _.chain(value).
          throw new Error(CHAIN_ERROR);
        } else if (lodashObjs[node.object.name]) {
          // Transform _.foo() to _foo().
          path.replaceWith(importMethod(node.property.name, file));
        } else if (fpObjs[node.object.name]) {
          importMethod(node.property.name, file);
          node.object = lodashFpIdentifier;
        }
      },


      // Allow things like `var x = y || _.noop` (see #28)
      LogicalExpression: buildExpressionHandler(['left', 'right']),

      // Allow things like `var x = y ? _.identity : _.noop` (see #28)
      ConditionalExpression: buildExpressionHandler(['test', 'consequent', 'alternate'])
    }
  };

  function buildExpressionHandler(props) {
    return function (path) {
      var node = path.node;
      var file = path.hub.file;


      props.forEach(function (prop) {
        var n = node[prop],
            name = n.name;
        if (!t.isIdentifier(n)) return;

        if (specified[name]) {
          node[prop] = importMethod(specified[name], file);
        } else if (fpSpecified[name]) {
          // Transform map() to fp.map() in order to avoid destructuring fp.
          importMethod(fpSpecified[name], file);
          node[prop] = t.memberExpression(lodashFpIdentifier, t.identifier(fpSpecified[name]));
        }
      });
    };
  }
};

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodashModules = require('./lodash-modules');

var _lodashModules2 = _interopRequireDefault(_lodashModules);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }